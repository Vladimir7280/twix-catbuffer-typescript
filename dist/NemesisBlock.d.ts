import { Address } from './Address';
import { Amount } from './Amount';
import { BlockCollectedEpochFees } from './BlockCollectedEpochFees';
import { BlockFeeMultiplier } from './BlockFeeMultiplier';
import { BlockFeeToPay } from './BlockFeeToPay';
import { BlockInflation } from './BlockInflation';
import { BlockInflationMultiplier } from './BlockInflationMultiplier';
import { BlockTotalSupply } from './BlockTotalSupply';
import { BlockType } from './BlockType';
import { Difficulty } from './Difficulty';
import { Hash256 } from './Hash256';
import { Height } from './Height';
import { NetworkType } from './NetworkType';
import { PublicKey } from './PublicKey';
import { Serializer } from './Serializer';
import { Signature } from './Signature';
import { Timestamp } from './Timestamp';
import { Transaction } from './Transaction';
import { VrfProof } from './VrfProof';
export interface NemesisBlockParams {
    signature: Signature;
    signerPublicKey: PublicKey;
    version: number;
    network: NetworkType;
    type: BlockType;
    height: Height;
    timestamp: Timestamp;
    difficulty: Difficulty;
    generationHashProof: VrfProof;
    previousBlockHash: Hash256;
    transactionsHash: Hash256;
    receiptsHash: Hash256;
    stateHash: Hash256;
    beneficiaryAddress: Address;
    feeMultiplier: BlockFeeMultiplier;
    totalSupply: BlockTotalSupply;
    feeTopay: BlockFeeToPay;
    inflation: BlockInflation;
    collectedEpochFees: BlockCollectedEpochFees;
    inflationMultiplier: BlockInflationMultiplier;
    votingEligibleAccountsCount: number;
    harvestingEligibleAccountsCount: bigint;
    totalVotingBalance: Amount;
    previousImportanceBlockHash: Hash256;
    transactions: Transaction[];
}
export declare class NemesisBlock implements Serializer {
    readonly BLOCK_VERSION = 1;
    readonly BLOCK_TYPE = 32835;
    readonly signature: Signature;
    readonly signerPublicKey: PublicKey;
    readonly version: number;
    readonly network: NetworkType;
    readonly type: BlockType;
    readonly height: Height;
    readonly timestamp: Timestamp;
    readonly difficulty: Difficulty;
    readonly generationHashProof: VrfProof;
    readonly previousBlockHash: Hash256;
    readonly transactionsHash: Hash256;
    readonly receiptsHash: Hash256;
    readonly stateHash: Hash256;
    readonly beneficiaryAddress: Address;
    readonly feeMultiplier: BlockFeeMultiplier;
    readonly totalSupply: BlockTotalSupply;
    readonly feeTopay: BlockFeeToPay;
    readonly inflation: BlockInflation;
    readonly collectedEpochFees: BlockCollectedEpochFees;
    readonly inflationMultiplier: BlockInflationMultiplier;
    readonly votingEligibleAccountsCount: number;
    readonly harvestingEligibleAccountsCount: bigint;
    readonly totalVotingBalance: Amount;
    readonly previousImportanceBlockHash: Hash256;
    readonly transactions: Transaction[];
    constructor({ signature, signerPublicKey, version, network, type, height, timestamp, difficulty, generationHashProof, previousBlockHash, transactionsHash, receiptsHash, stateHash, beneficiaryAddress, feeMultiplier, totalSupply, feeTopay, inflation, collectedEpochFees, inflationMultiplier, votingEligibleAccountsCount, harvestingEligibleAccountsCount, totalVotingBalance, previousImportanceBlockHash, transactions, }: NemesisBlockParams);
    static deserialize(payload: Uint8Array): NemesisBlock;
    get size(): number;
    serialize(): Uint8Array;
}
